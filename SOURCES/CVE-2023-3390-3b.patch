From 777e2f5a86a111b4eb12af7c59c5f1d4398f8ed4 Mon Sep 17 00:00:00 2001
From: Ryan Sullivan <rysulliv@redhat.com>
Date: Tue, 5 Sep 2023 17:48:47 -0400
Subject: [KPATCH ] kpatch fixes for CVE-2023-3390


Kernels:
5.14.0-284.18.1.el9_2
5.14.0-284.25.1.el9_2

Changes since last build:
arches: x86_64 ppc64le

---------------------------

Modifications:
- adds __attribute__((optimize("-fno-optimize-sibling-calls"))) to
nf_tables_rule_release() and nf_tables_deactivate_set()

- Replaces enum nft_trans_phase::NFT_TRANS_PREPARE_ERROR with a
preprocessor macro to avoid reindexing the existing enum members

- edits switch statements involving NFT_TRANS_PREPARE_ERROR to
evaluate it as an integer

- creates three shadow variables to imitate the nft_chain,
nft_chain_bound and nft_rule_bound struct fields created

- leaves nft_chain_add locally scoped to nf_tables_api.c

- leaves nf_tables_rule_release globally scoped in nf_tables.h

- Creates klp_ wrappers for locally scoped nft_rule_expr_deactivate
and nf_tables_rule_destroy so nft_immediate.c may call it

- moves definitions of nft_setelem_validate() and
nft_set_catchall_validate() from nf_tables.h to new file klp_nf_tables.h
future commits will also add to this file

commit ed42ac6771163b0e125d4af5451aecc51b8a08db
Author: Florian Westphal <fwestpha@redhat.com>
Date:   Tue Apr 25 17:16:36 2023 +0200

    netfilter: nf_tables: validate catch-all set elements

    Bugzilla: https://bugzilla.redhat.com/2216160
    CVE: CVE-2023-3390
    Y-Commit: 39bf8040d335cee3f4296989caf720814e992bad

    O-Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=2189550
    Upstream Status: commit d46fc894147cf

    commit d46fc894147cf98dd6e8210aa99ed46854191840
    Author: Pablo Neira Ayuso <pablo@netfilter.org>
    Date:   Mon Apr 17 12:14:29 2023 +0200

        netfilter: nf_tables: validate catch-all set elements

        catch-all set element might jump/goto to chain that uses expressions
        that require validation.

        Fixes: aaa31047a6d2 ("netfilter: nftables: add catch-all set element support")
        Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

    Signed-off-by: Florian Westphal <fwestpha@redhat.com>
    Signed-off-by: Herton R. Krzesinski <herton@redhat.com>

    v2:
    - Changed CVE tag from CVE-2023-3117 to CVE-2023-3390.

    Signed-off-by: Patrick Talbert <ptalbert@redhat.com>

commit 41feaa1077b939e0afd0e7764242ce5d8c97d967
Author: Phil Sutter <psutter@redhat.com>
Date:   Wed Jun 21 16:35:28 2023 +0200

    netfilter: nf_tables: incorrect error path handling with NFT_MSG_NEWRULE

    Bugzilla: https://bugzilla.redhat.com/2216160
    CVE: CVE-2023-3390
    Y-Commit: c13a47c89548ca9a2132ef36d037a7418dc2673b

    O-Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=2213271
    Upstream Status: commit 1240eb93f0616
    O-CVE: CVE-2023-3117

    commit 1240eb93f0616b21c675416516ff3d74798fdc97
    Author: Pablo Neira Ayuso <pablo@netfilter.org>
    Date:   Thu Jun 8 02:32:02 2023 +0200

        netfilter: nf_tables: incorrect error path handling with NFT_MSG_NEWRULE

        In case of error when adding a new rule that refers to an anonymous set,
        deactivate expressions via NFT_TRANS_PREPARE state, not NFT_TRANS_RELEASE.
        Thus, the lookup expression marks anonymous sets as inactive in the next
        generation to ensure it is not reachable in this transaction anymore and
        decrement the set refcount as introduced by c1592a89942e ("netfilter:
        nf_tables: deactivate anonymous set from preparation phase"). The abort
        step takes care of undoing the anonymous set.

        This is also consistent with rule deletion, where NFT_TRANS_PREPARE is
        used. Note that this error path is exercised in the preparation step of
        the commit protocol. This patch replaces nf_tables_rule_release() by the
        deactivate and destroy calls, this time with NFT_TRANS_PREPARE.

        Due to this incorrect error handling, it is possible to access a
        dangling pointer to the anonymous set that remains in the transaction
        list.

        [1009.379054] BUG: KASAN: use-after-free in nft_set_lookup_global+0x147/0x1a0 [nf_tables]
        [1009.379106] Read of size 8 at addr ffff88816c4c8020 by task nft-rule-add/137110
        [1009.379116] CPU: 7 PID: 137110 Comm: nft-rule-add Not tainted 6.4.0-rc4+ #256
        [1009.379128] Call Trace:
        [1009.379132]  <TASK>
        [1009.379135]  dump_stack_lvl+0x33/0x50
        [1009.379146]  ? nft_set_lookup_global+0x147/0x1a0 [nf_tables]
        [1009.379191]  print_address_description.constprop.0+0x27/0x300
        [1009.379201]  kasan_report+0x107/0x120
        [1009.379210]  ? nft_set_lookup_global+0x147/0x1a0 [nf_tables]
        [1009.379255]  nft_set_lookup_global+0x147/0x1a0 [nf_tables]
        [1009.379302]  nft_lookup_init+0xa5/0x270 [nf_tables]
        [1009.379350]  nf_tables_newrule+0x698/0xe50 [nf_tables]
        [1009.379397]  ? nf_tables_rule_release+0xe0/0xe0 [nf_tables]
        [1009.379441]  ? kasan_unpoison+0x23/0x50
        [1009.379450]  nfnetlink_rcv_batch+0x97c/0xd90 [nfnetlink]
        [1009.379470]  ? nfnetlink_rcv_msg+0x480/0x480 [nfnetlink]
        [1009.379485]  ? __alloc_skb+0xb8/0x1e0
        [1009.379493]  ? __alloc_skb+0xb8/0x1e0
        [1009.379502]  ? entry_SYSCALL_64_after_hwframe+0x46/0xb0
        [1009.379509]  ? unwind_get_return_address+0x2a/0x40
        [1009.379517]  ? write_profile+0xc0/0xc0
        [1009.379524]  ? avc_lookup+0x8f/0xc0
        [1009.379532]  ? __rcu_read_unlock+0x43/0x60

        Fixes: 958bee14d071 ("netfilter: nf_tables: use new transaction infrastructure to handle sets")
        Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

    Signed-off-by: Phil Sutter <psutter@redhat.com>
    Signed-off-by: Herton R. Krzesinski <herton@redhat.com>

    v2:
    - Changed CVE tag from CVE-2023-3117 to CVE-2023-3390.

    Signed-off-by: Patrick Talbert <ptalbert@redhat.com>

commit bd60047accb6c00090227a8ee59e439eab323df8
Author: Phil Sutter <psutter@redhat.com>
Date:   Fri Jun 23 13:06:39 2023 +0200

    netfilter: nf_tables: fix chain binding transaction logic

    Bugzilla: https://bugzilla.redhat.com/2216160
    CVE: CVE-2023-3390
    Y-Commit: ee6418b4380b9e1f45531f3946e01900e63f331a

    O-Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=2213271
    Upstream Status: commit 4bedf9eee0162
    O-CVE: CVE-2023-3117

    commit 4bedf9eee016286c835e3d8fa981ddece5338795
    Author: Pablo Neira Ayuso <pablo@netfilter.org>
    Date:   Fri Jun 16 14:45:22 2023 +0200

        netfilter: nf_tables: fix chain binding transaction logic

        Add bound flag to rule and chain transactions as in 6a0a8d10a366
        ("netfilter: nf_tables: use-after-free in failing rule with bound set")
        to skip them in case that the chain is already bound from the abort
        path.

        This patch fixes an imbalance in the chain use refcnt that triggers a
        WARN_ON on the table and chain destroy path.

        This patch also disallows nested chain bindings, which is not
        supported from userspace.

        The logic to deal with chain binding in nft_data_hold() and
        nft_data_release() is not correct. The NFT_TRANS_PREPARE state needs a
        special handling in case a chain is bound but next expressions in the
        same rule fail to initialize as described by 1240eb93f061 ("netfilter:
        nf_tables: incorrect error path handling with NFT_MSG_NEWRULE").

        The chain is left bound if rule construction fails, so the objects
        stored in this chain (and the chain itself) are released by the
        transaction records from the abort path, follow up patch ("netfilter:
        nf_tables: add NFT_TRANS_PREPARE_ERROR to deal with bound set/chain")
        completes this error handling.

        When deleting an existing rule, chain bound flag is set off so the
        rule expression .destroy path releases the objects.

        Fixes: d0e2c7de92c7 ("netfilter: nf_tables: add NFT_CHAIN_BINDING")
        Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

    Signed-off-by: Phil Sutter <psutter@redhat.com>
    Signed-off-by: Herton R. Krzesinski <herton@redhat.com>

    v2:
    - Changed CVE tag from CVE-2023-3117 to CVE-2023-3390.

    Signed-off-by: Patrick Talbert <ptalbert@redhat.com>

commit df8ffc3e4e838d1126cde3a9e4ad71d68f86ab5e
Author: Phil Sutter <psutter@redhat.com>
Date:   Fri Jun 23 13:06:40 2023 +0200

    netfilter: nf_tables: add NFT_TRANS_PREPARE_ERROR to deal with bound set/chain

    Bugzilla: https://bugzilla.redhat.com/2216160
    CVE: CVE-2023-3390
    Y-Commit: 5b561f7ecb380535c27631852a78272fbceabb83

    O-Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=2213271
    Upstream Status: commit 26b5a5712eb85
    O-CVE: CVE-2023-3117

    commit 26b5a5712eb85e253724e56a54c17f8519bd8e4e
    Author: Pablo Neira Ayuso <pablo@netfilter.org>
    Date:   Fri Jun 16 14:45:26 2023 +0200

        netfilter: nf_tables: add NFT_TRANS_PREPARE_ERROR to deal with bound set/chain

        Add a new state to deal with rule expressions deactivation from the
        newrule error path, otherwise the anonymous set remains in the list in
        inactive state for the next generation. Mark the set/chain transaction
        as unbound so the abort path releases this object, set it as inactive in
        the next generation so it is not reachable anymore from this transaction
        and reference counter is dropped.

        Fixes: 1240eb93f061 ("netfilter: nf_tables: incorrect error path handling with NFT_MSG_NEWRULE")
        Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

    Signed-off-by: Phil Sutter <psutter@redhat.com>
    Signed-off-by: Herton R. Krzesinski <herton@redhat.com>

    v2:
    - Changed CVE tag from CVE-2023-3117 to CVE-2023-3390.

    Signed-off-by: Patrick Talbert <ptalbert@redhat.com>

commit 47c5ce07eebcd53c26391a0072a57f4865792aa1
Author: Phil Sutter <psutter@redhat.com>
Date:   Tue Jun 27 22:09:05 2023 +0200

    netfilter: nf_tables: unbind non-anonymous set if rule construction fails

    Bugzilla: https://bugzilla.redhat.com/2216160
    CVE: CVE-2023-3390
    Y-Commit: 3a65137b4d267fed12f18af7ea79ed37e6f65014

    O-Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=2213271
    Upstream Status: net.git commit 3e70489721b6c
    O-CVE: CVE-2023-3117

    commit 3e70489721b6c870252c9082c496703677240f53
    Author: Pablo Neira Ayuso <pablo@netfilter.org>
    Date:   Mon Jun 26 00:42:18 2023 +0200

        netfilter: nf_tables: unbind non-anonymous set if rule construction fails

        Otherwise a dangling reference to a rule object that is gone remains
        in the set binding list.

        Fixes: 26b5a5712eb8 ("netfilter: nf_tables: add NFT_TRANS_PREPARE_ERROR to deal with bound set/chain")
        Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

    Signed-off-by: Phil Sutter <psutter@redhat.com>
    Signed-off-by: Herton R. Krzesinski <herton@redhat.com>

    v2:
    - Changed CVE tag from CVE-2023-3117 to CVE-2023-3390.

    Signed-off-by: Patrick Talbert <ptalbert@redhat.com>

Signed-off-by: Ryan Sullivan <rysulliv@redhat.com>
---
 include/net/netfilter/klp_nf_tables.h |  23 ++
 net/netfilter/nf_tables_api.c         | 289 ++++++++++++++++++++++----
 net/netfilter/nft_immediate.c         |  91 +++++++-
 net/netfilter/nft_lookup.c            |  37 +---
 4 files changed, 356 insertions(+), 84 deletions(-)
 create mode 100644 include/net/netfilter/klp_nf_tables.h

diff --git a/include/net/netfilter/klp_nf_tables.h b/include/net/netfilter/klp_nf_tables.h
new file mode 100644
index 000000000000..397c7d28679c
--- /dev/null
+++ b/include/net/netfilter/klp_nf_tables.h
@@ -0,0 +1,23 @@
+#ifndef KLP_NF_TABLES
+#define KLP_NF_TABLES
+
+#define NFT_TRANS_PREPARE_ERROR (NFT_TRANS_RELEASE+1)
+
+/* kpatch CVE-2023-3390 updates to include/net/netfilter/nf_tables.h */
+
+int nft_setelem_validate(const struct nft_ctx *ctx, struct nft_set *set,
+			 const struct nft_set_iter *iter,
+			 struct nft_set_elem *elem);
+int nft_set_catchall_validate(const struct nft_ctx *ctx, struct nft_set *set);
+int nf_tables_bind_chain(const struct nft_ctx *ctx, struct nft_chain *chain);
+void nft_rule_expr_activate(const struct nft_ctx *ctx, struct nft_rule *rule);
+void klp_nft_rule_expr_deactivate(const struct nft_ctx *ctx, struct nft_rule *rule,
+			      enum nft_trans_phase phase);
+void klp_nf_tables_rule_destroy(const struct nft_ctx *ctx, struct nft_rule *rule);
+void nf_tables_unbind_chain(const struct nft_ctx *ctx, struct nft_chain *chain);
+static inline bool nft_chain_binding(const struct nft_chain *chain)
+{
+	return chain->flags & NFT_CHAIN_BINDING;
+}
+
+#endif /* KLP_NF_TABLES */
\ No newline at end of file
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index a0dab76e7770..8e7118748211 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -22,6 +22,12 @@
 #include <net/netfilter/nf_tables_offload.h>
 #include <net/net_namespace.h>
 #include <net/sock.h>
+#include <net/netfilter/klp_nf_tables.h>
+#include <linux/livepatch.h>
+
+#define KLP_CVE_2023_3390_rule_bound	0x223012212000
+#define KLP_CVE_2023_3390_chain		0x223012212001
+#define KLP_CVE_2023_3390_chain_bound	0x223012212002
 
 #define NFT_MODULE_AUTOLOAD_LIMIT (MODULE_NAME_LEN - sizeof("nft-expr-255-"))
 
@@ -168,10 +174,14 @@ static struct nft_trans *nft_trans_alloc(const struct nft_ctx *ctx,
 static void nft_trans_destroy(struct nft_trans *trans)
 {
 	list_del(&trans->list);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_rule_bound, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain_bound, NULL);
 	kfree(trans);
 }
 
-static void nft_set_trans_bind(const struct nft_ctx *ctx, struct nft_set *set)
+static void __nft_set_trans_bind(const struct nft_ctx *ctx, struct nft_set *set,
+				 bool bind)
 {
 	struct nftables_pernet *nft_net;
 	struct net *net = ctx->net;
@@ -185,16 +195,89 @@ static void nft_set_trans_bind(const struct nft_ctx *ctx, struct nft_set *set)
 		switch (trans->msg_type) {
 		case NFT_MSG_NEWSET:
 			if (nft_trans_set(trans) == set)
-				nft_trans_set_bound(trans) = true;
+				nft_trans_set_bound(trans) = bind;
 			break;
 		case NFT_MSG_NEWSETELEM:
 			if (nft_trans_elem_set(trans) == set)
-				nft_trans_elem_set_bound(trans) = true;
+				nft_trans_elem_set_bound(trans) = bind;
 			break;
 		}
 	}
 }
 
+static void nft_set_trans_bind(const struct nft_ctx *ctx, struct nft_set *set)
+{
+	return __nft_set_trans_bind(ctx, set, true);
+}
+
+static void nft_set_trans_unbind(const struct nft_ctx *ctx, struct nft_set *set)
+{
+	return __nft_set_trans_bind(ctx, set, false);
+}
+
+static void __nft_chain_trans_bind(const struct nft_ctx *ctx,
+				   struct nft_chain *chain, bool bind)
+{
+	struct nftables_pernet *nft_net;
+	struct net *net = ctx->net;
+	struct nft_trans *trans;
+	struct nft_chain **klp_chain;
+	bool *klp_rule_bound, *klp_chain_bound;
+
+	if (!nft_chain_binding(chain))
+		return;
+
+	nft_net = nft_pernet(net);
+	list_for_each_entry_reverse(trans, &nft_net->commit_list, list) {
+		switch (trans->msg_type) {
+		case NFT_MSG_NEWCHAIN:
+			klp_chain = klp_shadow_get(trans, KLP_CVE_2023_3390_chain);
+			if (klp_chain && *klp_chain == chain) {
+				klp_chain_bound = klp_shadow_get(trans, KLP_CVE_2023_3390_chain_bound);
+				if(klp_chain_bound)
+					*klp_chain_bound = bind;
+			}
+			break;
+		case NFT_MSG_NEWRULE:
+			if (trans->ctx.chain == chain){
+				klp_rule_bound = klp_shadow_get(trans, KLP_CVE_2023_3390_rule_bound);
+				if(klp_rule_bound)
+					*klp_rule_bound = bind;
+			}
+			break;
+		}
+	}
+}
+
+static void nft_chain_trans_bind(const struct nft_ctx *ctx,
+				 struct nft_chain *chain)
+{
+	__nft_chain_trans_bind(ctx, chain, true);
+}
+
+int nf_tables_bind_chain(const struct nft_ctx *ctx, struct nft_chain *chain)
+{
+	if (!nft_chain_binding(chain))
+		return 0;
+
+	if (nft_chain_binding(ctx->chain))
+		return -EOPNOTSUPP;
+
+	if (chain->bound)
+		return -EBUSY;
+
+	chain->bound = true;
+	chain->use++;
+	nft_chain_trans_bind(ctx, chain);
+
+	return 0;
+}
+
+void nf_tables_unbind_chain(const struct nft_ctx *ctx, struct nft_chain *chain)
+{
+	__nft_chain_trans_bind(ctx, chain, false);
+}
+
 static int nft_netdev_register_hooks(struct net *net,
 				     struct list_head *hook_list)
 {
@@ -327,11 +410,27 @@ static int nft_deltable(struct nft_ctx *ctx)
 static struct nft_trans *nft_trans_chain_add(struct nft_ctx *ctx, int msg_type)
 {
 	struct nft_trans *trans;
+	struct nft_chain **klp_chain;
+	bool *klp_chain_bound;
 
 	trans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_chain));
 	if (trans == NULL)
 		return ERR_PTR(-ENOMEM);
 
+	klp_chain = klp_shadow_alloc(trans, KLP_CVE_2023_3390_chain,
+				 sizeof(*klp_chain), GFP_KERNEL, NULL, NULL);
+	if (!klp_chain) {
+		nft_trans_destroy(trans);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	klp_chain_bound = klp_shadow_alloc(trans, KLP_CVE_2023_3390_chain_bound,
+				 sizeof(*klp_chain_bound), GFP_KERNEL, NULL, NULL);
+	if (!klp_chain_bound) {
+		nft_trans_destroy(trans);
+		return ERR_PTR(-ENOMEM);
+	}
+
 	if (msg_type == NFT_MSG_NEWCHAIN) {
 		nft_activate_next(ctx->net, ctx->chain);
 
@@ -340,8 +439,9 @@ static struct nft_trans *nft_trans_chain_add(struct nft_ctx *ctx, int msg_type)
 				ntohl(nla_get_be32(ctx->nla[NFTA_CHAIN_ID]));
 		}
 	}
-
+	*klp_chain = ctx->chain;
 	nft_trans_commit_list_add_tail(ctx->net, trans);
+
 	return trans;
 }
 
@@ -359,8 +459,7 @@ static int nft_delchain(struct nft_ctx *ctx)
 	return 0;
 }
 
-static void nft_rule_expr_activate(const struct nft_ctx *ctx,
-				   struct nft_rule *rule)
+void nft_rule_expr_activate(const struct nft_ctx *ctx, struct nft_rule *rule)
 {
 	struct nft_expr *expr;
 
@@ -373,9 +472,8 @@ static void nft_rule_expr_activate(const struct nft_ctx *ctx,
 	}
 }
 
-static void nft_rule_expr_deactivate(const struct nft_ctx *ctx,
-				     struct nft_rule *rule,
-				     enum nft_trans_phase phase)
+static void nft_rule_expr_deactivate(const struct nft_ctx *ctx, struct nft_rule *rule,
+			      enum nft_trans_phase phase)
 {
 	struct nft_expr *expr;
 
@@ -388,6 +486,11 @@ static void nft_rule_expr_deactivate(const struct nft_ctx *ctx,
 	}
 }
 
+void klp_nft_rule_expr_deactivate(const struct nft_ctx *ctx, struct nft_rule *rule,
+			      enum nft_trans_phase phase){
+	nft_rule_expr_deactivate(ctx, rule, phase);
+}
+
 static int
 nf_tables_delrule_deactivate(struct nft_ctx *ctx, struct nft_rule *rule)
 {
@@ -404,11 +507,19 @@ static struct nft_trans *nft_trans_rule_add(struct nft_ctx *ctx, int msg_type,
 					    struct nft_rule *rule)
 {
 	struct nft_trans *trans;
+	bool *klp_rule_bound;
 
 	trans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_rule));
 	if (trans == NULL)
 		return NULL;
 
+	klp_rule_bound = klp_shadow_alloc(trans, KLP_CVE_2023_3390_rule_bound,
+				 sizeof(*klp_rule_bound), GFP_KERNEL, NULL, NULL);
+	if (!klp_rule_bound) {
+		nft_trans_destroy(trans);
+		return NULL;
+	}
+
 	if (msg_type == NFT_MSG_NEWRULE && ctx->nla[NFTA_RULE_ID] != NULL) {
 		nft_trans_rule_id(trans) =
 			ntohl(nla_get_be32(ctx->nla[NFTA_RULE_ID]));
@@ -2281,6 +2392,8 @@ static int nf_tables_updchain(struct nft_ctx *ctx, u8 genmask, u8 policy,
 	struct nft_chain_hook hook;
 	struct nf_hook_ops *ops;
 	struct nft_trans *trans;
+	struct nft_chain **klp_chain;
+	bool *klp_chain_bound;
 	int err;
 
 	if (chain->flags ^ flags)
@@ -2349,6 +2462,17 @@ static int nf_tables_updchain(struct nft_ctx *ctx, u8 genmask, u8 policy,
 	if (trans == NULL)
 		goto err;
 
+	klp_chain = klp_shadow_alloc(trans, KLP_CVE_2023_3390_chain,
+				 sizeof(*klp_chain), GFP_KERNEL, NULL, NULL);
+	if (!klp_chain)
+		goto err;
+
+	klp_chain_bound = klp_shadow_alloc(trans, KLP_CVE_2023_3390_chain_bound,
+				 sizeof(*klp_chain_bound), GFP_KERNEL, NULL, NULL);
+	if (!klp_chain_bound) {
+		goto klp_err1;
+	}
+
 	nft_trans_chain_stats(trans) = stats;
 	nft_trans_chain_update(trans) = true;
 
@@ -2366,7 +2490,7 @@ static int nf_tables_updchain(struct nft_ctx *ctx, u8 genmask, u8 policy,
 		err = -ENOMEM;
 		name = nla_strdup(nla[NFTA_CHAIN_NAME], GFP_KERNEL);
 		if (!name)
-			goto err;
+			goto klp_err2;
 
 		err = -EEXIST;
 		list_for_each_entry(tmp, &nft_net->commit_list, list) {
@@ -2377,7 +2501,7 @@ static int nf_tables_updchain(struct nft_ctx *ctx, u8 genmask, u8 policy,
 			    strcmp(name, nft_trans_chain_name(tmp)) == 0) {
 				NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_NAME]);
 				kfree(name);
-				goto err;
+				goto klp_err2;
 			}
 		}
 
@@ -2386,6 +2510,11 @@ static int nf_tables_updchain(struct nft_ctx *ctx, u8 genmask, u8 policy,
 	nft_trans_commit_list_add_tail(ctx->net, trans);
 
 	return 0;
+
+klp_err2:
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain_bound, NULL);
+klp_err1:
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain, NULL);
 err:
 	free_percpu(stats);
 	kfree(trans);
@@ -3221,8 +3350,7 @@ static int nf_tables_getrule(struct sk_buff *skb, const struct nfnl_info *info,
 	return err;
 }
 
-static void nf_tables_rule_destroy(const struct nft_ctx *ctx,
-				   struct nft_rule *rule)
+static void nf_tables_rule_destroy(const struct nft_ctx *ctx, struct nft_rule *rule)
 {
 	struct nft_expr *expr, *next;
 
@@ -3239,6 +3367,11 @@ static void nf_tables_rule_destroy(const struct nft_ctx *ctx,
 	kfree(rule);
 }
 
+void klp_nf_tables_rule_destroy(const struct nft_ctx *ctx, struct nft_rule *rule){
+	nf_tables_rule_destroy(ctx, rule);
+}
+
+__attribute__((optimize("-fno-optimize-sibling-calls")))
 void nf_tables_rule_release(const struct nft_ctx *ctx, struct nft_rule *rule)
 {
 	nft_rule_expr_deactivate(ctx, rule, NFT_TRANS_RELEASE);
@@ -3295,6 +3428,64 @@ static int nft_table_validate(struct net *net, const struct nft_table *table)
 	return 0;
 }
 
+int nft_setelem_validate(const struct nft_ctx *ctx, struct nft_set *set,
+			 const struct nft_set_iter *iter,
+			 struct nft_set_elem *elem)
+{
+	const struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);
+	struct nft_ctx *pctx = (struct nft_ctx *)ctx;
+	const struct nft_data *data;
+	int err;
+
+	if (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&
+	    *nft_set_ext_flags(ext) & NFT_SET_ELEM_INTERVAL_END)
+		return 0;
+
+	data = nft_set_ext_data(ext);
+	switch (data->verdict.code) {
+	case NFT_JUMP:
+	case NFT_GOTO:
+		pctx->level++;
+		err = nft_chain_validate(ctx, data->verdict.chain);
+		if (err < 0)
+			return err;
+		pctx->level--;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+struct nft_set_elem_catchall {
+	struct list_head	list;
+	struct rcu_head		rcu;
+	void			*elem;
+};
+
+int nft_set_catchall_validate(const struct nft_ctx *ctx, struct nft_set *set)
+{
+	u8 genmask = nft_genmask_next(ctx->net);
+	struct nft_set_elem_catchall *catchall;
+	struct nft_set_elem elem;
+	struct nft_set_ext *ext;
+	int ret = 0;
+
+	list_for_each_entry_rcu(catchall, &set->catchall_list, list) {
+		ext = nft_set_elem_ext(set, catchall->elem);
+		if (!nft_set_elem_active(ext, genmask))
+			continue;
+
+		elem.priv = catchall->elem;
+		ret = nft_setelem_validate(ctx, set, NULL, &elem);
+		if (ret < 0)
+			return ret;
+	}
+
+	return ret;
+}
+
 static struct nft_rule *nft_rule_lookup_byid(const struct net *net,
 					     const struct nft_chain *chain,
 					     const struct nlattr *nla);
@@ -3517,7 +3708,8 @@ static int nf_tables_newrule(struct sk_buff *skb, const struct nfnl_info *info,
 	if (flow)
 		nft_flow_rule_destroy(flow);
 err_release_rule:
-	nf_tables_rule_release(&ctx, rule);
+	nft_rule_expr_deactivate(&ctx, rule, NFT_TRANS_PREPARE_ERROR);
+	nf_tables_rule_destroy(&ctx, rule);
 err_release_expr:
 	for (i = 0; i < n; i++) {
 		if (expr_info[i].ops) {
@@ -4601,12 +4793,6 @@ static int nf_tables_newset(struct sk_buff *skb, const struct nfnl_info *info,
 	return err;
 }
 
-struct nft_set_elem_catchall {
-	struct list_head	list;
-	struct rcu_head		rcu;
-	void			*elem;
-};
-
 static void nft_set_catchall_destroy(const struct nft_ctx *ctx,
 				     struct nft_set *set)
 {
@@ -4799,11 +4985,21 @@ void nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set)
 }
 EXPORT_SYMBOL_GPL(nf_tables_activate_set);
 
+__attribute__((optimize("-fno-optimize-sibling-calls")))
 void nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,
 			      struct nft_set_binding *binding,
 			      enum nft_trans_phase phase)
 {
-	switch (phase) {
+	switch ((int)phase) {
+	case NFT_TRANS_PREPARE_ERROR:
+		nft_set_trans_unbind(ctx, set);
+		if (nft_set_is_anonymous(set))
+			nft_deactivate_next(ctx->net, set);
+		else
+			list_del_rcu(&binding->list);
+
+		set->use--;
+		break;
 	case NFT_TRANS_PREPARE:
 		if (nft_set_is_anonymous(set))
 			nft_deactivate_next(ctx->net, set);
@@ -6174,6 +6370,9 @@ static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
 err_set_full:
 	nft_setelem_remove(ctx->net, set, &elem);
 err_element_clash:
+	klp_shadow_free(trans, KLP_CVE_2023_3390_rule_bound, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain_bound, NULL);
 	kfree(trans);
 err_elem_expr:
 	if (obj)
@@ -6255,7 +6454,6 @@ static int nf_tables_newsetelem(struct sk_buff *skb,
 void nft_data_hold(const struct nft_data *data, enum nft_data_types type)
 {
 	struct nft_chain *chain;
-	struct nft_rule *rule;
 
 	if (type == NFT_DATA_VERDICT) {
 		switch (data->verdict.code) {
@@ -6263,15 +6461,6 @@ void nft_data_hold(const struct nft_data *data, enum nft_data_types type)
 		case NFT_GOTO:
 			chain = data->verdict.chain;
 			chain->use++;
-
-			if (!nft_chain_is_bound(chain))
-				break;
-
-			chain->table->use++;
-			list_for_each_entry(rule, &chain->rules, list)
-				chain->use++;
-
-			nft_chain_add(chain->table, chain);
 			break;
 		}
 	}
@@ -6383,6 +6572,9 @@ static int nft_del_setelem(struct nft_ctx *ctx, struct nft_set *set,
 	return 0;
 
 fail_ops:
+	klp_shadow_free(trans, KLP_CVE_2023_3390_rule_bound, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain_bound, NULL);
 	kfree(trans);
 fail_trans:
 	kfree(elem.priv);
@@ -6419,6 +6611,9 @@ static int nft_setelem_flush(const struct nft_ctx *ctx,
 
 	return 0;
 err1:
+	klp_shadow_free(trans, KLP_CVE_2023_3390_rule_bound, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain_bound, NULL);
 	kfree(trans);
 	return err;
 }
@@ -6772,6 +6967,9 @@ static int nf_tables_updobj(const struct nft_ctx *ctx,
 	return 0;
 
 err_free_trans:
+	klp_shadow_free(trans, KLP_CVE_2023_3390_rule_bound, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain_bound, NULL);
 	kfree(trans);
 err_trans:
 	module_put(type->owner);
@@ -7265,7 +7463,8 @@ void nf_tables_deactivate_flowtable(const struct nft_ctx *ctx,
 				    struct nft_flowtable *flowtable,
 				    enum nft_trans_phase phase)
 {
-	switch (phase) {
+	switch ((int)phase) {
+	case NFT_TRANS_PREPARE_ERROR:
 	case NFT_TRANS_PREPARE:
 	case NFT_TRANS_ABORT:
 	case NFT_TRANS_RELEASE:
@@ -8440,6 +8639,9 @@ static void nft_commit_release(struct nft_trans *trans)
 	if (trans->put_net)
 		put_net(trans->ctx.net);
 
+	klp_shadow_free(trans, KLP_CVE_2023_3390_rule_bound, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain_bound, NULL);
 	kfree(trans);
 }
 
@@ -9033,6 +9235,9 @@ static void nf_tables_abort_release(struct nft_trans *trans)
 			nf_tables_flowtable_destroy(nft_trans_flowtable(trans));
 		break;
 	}
+	klp_shadow_free(trans, KLP_CVE_2023_3390_rule_bound, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain, NULL);
+	klp_shadow_free(trans, KLP_CVE_2023_3390_chain_bound, NULL);
 	kfree(trans);
 }
 
@@ -9041,6 +9246,7 @@ static int __nf_tables_abort(struct net *net, enum nfnl_abort_action action)
 	struct nftables_pernet *nft_net = nft_pernet(net);
 	struct nft_trans *trans, *next;
 	struct nft_trans_elem *te;
+	bool *klp_rule_bound, *klp_chain_bound;
 
 	if (action == NFNL_ABORT_VALIDATE &&
 	    nf_tables_validate(net) < 0)
@@ -9077,7 +9283,9 @@ static int __nf_tables_abort(struct net *net, enum nfnl_abort_action action)
 				kfree(nft_trans_chain_name(trans));
 				nft_trans_destroy(trans);
 			} else {
-				if (nft_chain_is_bound(trans->ctx.chain)) {
+				klp_chain_bound = klp_shadow_get(trans, KLP_CVE_2023_3390_chain_bound);
+				if ((klp_chain_bound && *klp_chain_bound) ||
+				(!klp_chain_bound && nft_chain_is_bound(trans->ctx.chain))) {
 					nft_trans_destroy(trans);
 					break;
 				}
@@ -9094,6 +9302,11 @@ static int __nf_tables_abort(struct net *net, enum nfnl_abort_action action)
 			nft_trans_destroy(trans);
 			break;
 		case NFT_MSG_NEWRULE:
+			klp_rule_bound = klp_shadow_get(trans, KLP_CVE_2023_3390_rule_bound);
+			if (klp_rule_bound && *klp_rule_bound) {
+				nft_trans_destroy(trans);
+				break;
+			}
 			trans->ctx.chain->use--;
 			list_del_rcu(&nft_trans_rule(trans)->list);
 			nft_rule_expr_deactivate(&trans->ctx,
@@ -9646,22 +9859,12 @@ static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,
 static void nft_verdict_uninit(const struct nft_data *data)
 {
 	struct nft_chain *chain;
-	struct nft_rule *rule;
 
 	switch (data->verdict.code) {
 	case NFT_JUMP:
 	case NFT_GOTO:
 		chain = data->verdict.chain;
 		chain->use--;
-
-		if (!nft_chain_is_bound(chain))
-			break;
-
-		chain->table->use--;
-		list_for_each_entry(rule, &chain->rules, list)
-			chain->use--;
-
-		nft_chain_del(chain);
 		break;
 	}
 }
diff --git a/net/netfilter/nft_immediate.c b/net/netfilter/nft_immediate.c
index d0f67d325bdf..999b5c67f02e 100644
--- a/net/netfilter/nft_immediate.c
+++ b/net/netfilter/nft_immediate.c
@@ -14,6 +14,7 @@
 #include <net/netfilter/nf_tables_core.h>
 #include <net/netfilter/nf_tables.h>
 #include <net/netfilter/nf_tables_offload.h>
+#include <net/netfilter/klp_nf_tables.h>
 
 void nft_immediate_eval(const struct nft_expr *expr,
 			struct nft_regs *regs,
@@ -60,11 +61,9 @@ static int nft_immediate_init(const struct nft_ctx *ctx,
 		switch (priv->data.verdict.code) {
 		case NFT_JUMP:
 		case NFT_GOTO:
-			if (nft_chain_is_bound(chain)) {
-				err = -EBUSY;
-				goto err1;
-			}
-			chain->bound = true;
+			err = nf_tables_bind_chain(ctx, chain);
+			if (err < 0)
+				return err;
 			break;
 		default:
 			break;
@@ -82,6 +81,31 @@ static void nft_immediate_activate(const struct nft_ctx *ctx,
 				   const struct nft_expr *expr)
 {
 	const struct nft_immediate_expr *priv = nft_expr_priv(expr);
+	const struct nft_data *data = &priv->data;
+	struct nft_ctx chain_ctx;
+	struct nft_chain *chain;
+	struct nft_rule *rule;
+
+	if (priv->dreg == NFT_REG_VERDICT) {
+		switch (data->verdict.code) {
+		case NFT_JUMP:
+		case NFT_GOTO:
+			chain = data->verdict.chain;
+			if (!nft_chain_binding(chain))
+				break;
+
+			chain_ctx = *ctx;
+			chain_ctx.chain = chain;
+
+			list_for_each_entry(rule, &chain->rules, list)
+				nft_rule_expr_activate(&chain_ctx, rule);
+
+			nft_clear(ctx->net, chain);
+			break;
+		default:
+			break;
+		}
+	}
 
 	return nft_data_hold(&priv->data, nft_dreg_to_type(priv->dreg));
 }
@@ -91,6 +115,43 @@ static void nft_immediate_deactivate(const struct nft_ctx *ctx,
 				     enum nft_trans_phase phase)
 {
 	const struct nft_immediate_expr *priv = nft_expr_priv(expr);
+	const struct nft_data *data = &priv->data;
+	struct nft_ctx chain_ctx;
+	struct nft_chain *chain;
+	struct nft_rule *rule;
+
+	if (priv->dreg == NFT_REG_VERDICT) {
+		switch (data->verdict.code) {
+		case NFT_JUMP:
+		case NFT_GOTO:
+			chain = data->verdict.chain;
+			if (!nft_chain_binding(chain))
+				break;
+
+			chain_ctx = *ctx;
+			chain_ctx.chain = chain;
+
+			list_for_each_entry(rule, &chain->rules, list)
+				klp_nft_rule_expr_deactivate(&chain_ctx, rule, phase);
+
+			switch ((int)phase) {
+			case NFT_TRANS_PREPARE_ERROR:
+				nf_tables_unbind_chain(ctx, chain);
+				fallthrough;
+			case NFT_TRANS_PREPARE:
+				nft_deactivate_next(ctx->net, chain);
+				break;
+			default:
+				nft_chain_del(chain);
+				chain->bound = false;
+				chain->table->use--;
+				break;
+			}
+			break;
+		default:
+			break;
+		}
+	}
 
 	if (phase == NFT_TRANS_COMMIT)
 		return;
@@ -115,15 +176,27 @@ static void nft_immediate_destroy(const struct nft_ctx *ctx,
 	case NFT_GOTO:
 		chain = data->verdict.chain;
 
-		if (!nft_chain_is_bound(chain))
+		if (!nft_chain_binding(chain))
+			break;
+
+		/* Rule construction failed, but chain is already bound:
+		 * let the transaction records release this chain and its rules.
+		 */
+		if (chain->bound) {
+			chain->use--;
 			break;
+		}
 
+		/* Rule has been deleted, release chain and its rules. */
 		chain_ctx = *ctx;
 		chain_ctx.chain = chain;
 
-		list_for_each_entry_safe(rule, n, &chain->rules, list)
-			nf_tables_rule_release(&chain_ctx, rule);
-
+		chain->use--;
+		list_for_each_entry_safe(rule, n, &chain->rules, list) {
+			chain->use--;
+			list_del(&rule->list);
+			klp_nf_tables_rule_destroy(&chain_ctx, rule);
+		}
 		nf_tables_chain_destroy(&chain_ctx);
 		break;
 	default:
diff --git a/net/netfilter/nft_lookup.c b/net/netfilter/nft_lookup.c
index b53a9b807a46..5ac6097f6689 100644
--- a/net/netfilter/nft_lookup.c
+++ b/net/netfilter/nft_lookup.c
@@ -14,6 +14,7 @@
 #include <linux/netfilter/nf_tables.h>
 #include <net/netfilter/nf_tables.h>
 #include <net/netfilter/nf_tables_core.h>
+#include <net/netfilter/klp_nf_tables.h>
 
 struct nft_lookup {
 	struct nft_set			*set;
@@ -198,37 +199,6 @@ static int nft_lookup_dump(struct sk_buff *skb, const struct nft_expr *expr)
 	return -1;
 }
 
-static int nft_lookup_validate_setelem(const struct nft_ctx *ctx,
-				       struct nft_set *set,
-				       const struct nft_set_iter *iter,
-				       struct nft_set_elem *elem)
-{
-	const struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);
-	struct nft_ctx *pctx = (struct nft_ctx *)ctx;
-	const struct nft_data *data;
-	int err;
-
-	if (nft_set_ext_exists(ext, NFT_SET_EXT_FLAGS) &&
-	    *nft_set_ext_flags(ext) & NFT_SET_ELEM_INTERVAL_END)
-		return 0;
-
-	data = nft_set_ext_data(ext);
-	switch (data->verdict.code) {
-	case NFT_JUMP:
-	case NFT_GOTO:
-		pctx->level++;
-		err = nft_chain_validate(ctx, data->verdict.chain);
-		if (err < 0)
-			return err;
-		pctx->level--;
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
 static int nft_lookup_validate(const struct nft_ctx *ctx,
 			       const struct nft_expr *expr,
 			       const struct nft_data **d)
@@ -244,9 +214,12 @@ static int nft_lookup_validate(const struct nft_ctx *ctx,
 	iter.skip	= 0;
 	iter.count	= 0;
 	iter.err	= 0;
-	iter.fn		= nft_lookup_validate_setelem;
+	iter.fn		= nft_setelem_validate;
 
 	priv->set->ops->walk(ctx, priv->set, &iter);
+	if (!iter.err)
+		iter.err = nft_set_catchall_validate(ctx, priv->set);
+
 	if (iter.err < 0)
 		return iter.err;
 
-- 
2.41.0

